# iCyclist 技术文档

## 📑 目录

1. [核心技术架构](#核心技术架构)
2. [数据库设计详解](#数据库设计详解)
3. [关键功能实现](#关键功能实现)
4. [UI/UX设计规范](#uiux设计规范)
5. [性能优化方案](#性能优化方案)
6. [安全机制](#安全机制)
7. [API接口文档](#api接口文档)
8. [测试策略](#测试策略)

---

## 核心技术架构

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                         Presentation Layer                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ Activity │  │ Fragment │  │ Adapter  │  │  Dialog  │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│                         Business Layer                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │  ViewModel│  │ Manager  │  │  Utils   │  │  Helper  │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│                          Data Layer                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │  Room DB │  │SharedPref│  │  Network │  │  Storage │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### MVVM模式应用

虽然项目主要使用传统的MVC模式，但在部分模块中融入了MVVM思想：

```kotlin
// Fragment (View) 负责UI展示
class MomentFragment : Fragment() {
    private lateinit var adapter: CommunityPostAdapter
    
    private fun loadPosts() {
        lifecycleScope.launch {
            val posts = withContext(Dispatchers.IO) {
                database.communityPostDao().getAllPosts()
            }
            adapter.updateData(posts)
        }
    }
}

// UserManager (类似ViewModel) 负责业务逻辑
object UserManager {
    fun getCurrentUserEmail(context: Context): String? {
        return getEncryptedPreferences(context)
            .getString(KEY_CURRENT_USER_EMAIL, null)
    }
}

// Room Database (Model) 负责数据持久化
@Database(entities = [...], version = 5)
abstract class SportDatabase : RoomDatabase() {
    abstract fun communityPostDao(): CommunityPostDao
}
```

---

## 数据库设计详解

### ER关系图

```
┌─────────────┐
│    User     │ (SharedPreferences存储)
└─────────────┘
       │ 1
       │
       │ N
┌─────────────┐      N        ┌─────────────┐
│SportRecord  │◄──────────────│CommunityPost│
└─────────────┘                └─────────────┘
                                      │ 1
                               ┌──────┴──────┐
                               │ N           │ N
                        ┌─────────┐    ┌─────────┐
                        │Comment  │    │  Like   │
                        └─────────┘    └─────────┘

┌──────────────┐      1        ┌──────────────┐
│ForumCategory │◄──────────────│  ForumTopic  │
└──────────────┘       N        └──────────────┘
                                       │ 1
                                       │ N
                                ┌──────────────┐
                                │ ForumReply   │
                                └──────────────┘
```

### 表结构详解

#### 1. sport_records 表

**字段说明：**

| 字段名 | 类型 | 说明 | 约束 |
|--------|------|------|------|
| id | INTEGER | 主键，自增 | PRIMARY KEY |
| startTime | LONG | 开始时间戳（毫秒） | NOT NULL |
| endTime | LONG | 结束时间戳（毫秒） | NOT NULL |
| duration | LONG | 运动时长（秒） | NOT NULL |
| distance | FLOAT | 运动距离（米） | NOT NULL |
| averageSpeed | FLOAT | 平均速度（km/h） | NOT NULL |
| maxSpeed | FLOAT | 最大速度（km/h） | NOT NULL |
| calories | INTEGER | 消耗卡路里 | NOT NULL |
| trackPoints | TEXT | 轨迹坐标点JSON | NOT NULL |
| thumbnailPath | TEXT | 缩略图路径 | NULLABLE |

**索引设计：**
```sql
-- 按时间查询索引
CREATE INDEX idx_sport_start_time ON sport_records(startTime DESC);
```

**trackPoints JSON格式：**
```json
[
  {
    "latitude": 39.9042,
    "longitude": 116.4074,
    "timestamp": 1634567890000,
    "speed": 15.5
  },
  ...
]
```

#### 2. community_posts 表

**关联关系：**
- `sportRecordId` 外键关联 `sport_records.id`（可选）

**业务逻辑：**
- 普通帖子：`sportRecordId` 为 NULL
- 运动分享帖：包含 `sportRecordId`、`sportDistance`、`sportDuration`、`sportThumbPath`

#### 3. likes 表（联合主键）

**联合主键设计：**
```kotlin
@Entity(tableName = "likes", primaryKeys = ["postId", "userId"])
```

**优势：**
- 防止重复点赞
- 查询效率高
- 数据一致性保证

**查询示例：**
```kotlin
// 检查用户是否点赞
@Query("SELECT COUNT(*) FROM likes WHERE postId = :postId AND userId = :userId")
suspend fun isLiked(postId: Int, userId: String): Int

// 获取帖子点赞数
@Query("SELECT COUNT(*) FROM likes WHERE postId = :postId")
suspend fun getLikeCount(postId: Int): Int
```

### 数据库迁移策略

#### 版本迁移流程

```kotlin
// MIGRATION_4_5: 添加示例数据
private val MIGRATION_4_5 = object : Migration(4, 5) {
    override fun migrate(db: SupportSQLiteDatabase) {
        val currentTime = System.currentTimeMillis()
        
        // 1. 插入论坛主题数据
        db.execSQL("""
            INSERT INTO forum_topics 
            (categoryId, userId, userNickname, userAvatar, title, content, timestamp, replyCount) 
            VALUES (1, 'user@example.com', '骑行达人', 'ic_twotone_person_24', 
                    '求推荐入门级公路车', '预算5000左右...', $currentTime, 0)
        """)
        
        // 2. 插入回复数据
        db.execSQL("""
            INSERT INTO forum_replies 
            (topicId, userId, userNickname, userAvatar, content, timestamp) 
            VALUES (1, 'expert@example.com', '骑行专家', 'ic_twotone_person_24', 
                    '推荐美利达...', $currentTime)
        """)
        
        // 3. 更新主题回复计数
        db.execSQL("UPDATE forum_topics SET replyCount = 2 WHERE id = 1")
    }
}
```

#### 迁移注意事项

1. **保持向后兼容**：旧版本数据不丢失
2. **事务保证**：迁移失败自动回滚
3. **测试验证**：每次迁移后验证数据完整性
4. **版本控制**：严格递增版本号

---

## 关键功能实现

### 1. GPS轨迹追踪

#### 定位配置

```kotlin
// 初始化定位客户端
private fun initLocationClient() {
    locationClient = AMapLocationClient(requireContext().applicationContext)
    
    val option = AMapLocationClientOption().apply {
        // 定位模式
        locationMode = AMapLocationClientOption.AMapLocationMode.Hight_Accuracy
        
        // 定位间隔（毫秒）
        interval = 2000L  // 2秒更新一次
        
        // 是否返回地址信息
        isNeedAddress = false
        
        // 是否允许模拟位置
        isMockEnable = false
        
        // 设置定位超时时间
        httpTimeOut = 30000
        
        // 单次定位还是连续定位
        isOnceLocation = false
    }
    
    locationClient?.setLocationOption(option)
    locationClient?.setLocationListener(this)
}
```

#### 轨迹点采集算法

```kotlin
override fun onLocationChanged(location: AMapLocation?) {
    location?.let { loc ->
        if (loc.errorCode == 0) {
            val currentPoint = TrackPoint(
                latitude = loc.latitude,
                longitude = loc.longitude,
                timestamp = System.currentTimeMillis(),
                speed = loc.speed  // m/s
            )
            
            // 过滤无效点
            if (isValidPoint(currentPoint, lastPoint)) {
                trackPoints.add(currentPoint)
                
                // 绘制轨迹线
                updateMapTrack(currentPoint)
                
                // 更新统计数据
                updateSportData(currentPoint)
                
                lastPoint = currentPoint
            }
        }
    }
}

// 点有效性判断
private fun isValidPoint(current: TrackPoint, last: TrackPoint?): Boolean {
    if (last == null) return true
    
    // 1. 速度合理性检查（不超过60km/h）
    if (current.speed > 16.67f) return false  // 60km/h = 16.67m/s
    
    // 2. 距离合理性检查（两点间距离不超过100米）
    val distance = calculateDistance(last, current)
    if (distance > 100f) return false
    
    // 3. 时间间隔检查
    val timeInterval = current.timestamp - last.timestamp
    if (timeInterval < 1000) return false  // 至少1秒间隔
    
    return true
}
```

#### 距离计算（Haversine公式）

```kotlin
fun calculateDistance(point1: TrackPoint, point2: TrackPoint): Float {
    val R = 6371000.0  // 地球半径（米）
    
    val lat1 = Math.toRadians(point1.latitude)
    val lat2 = Math.toRadians(point2.latitude)
    val dLat = Math.toRadians(point2.latitude - point1.latitude)
    val dLon = Math.toRadians(point2.longitude - point1.longitude)
    
    val a = sin(dLat / 2) * sin(dLat / 2) +
            cos(lat1) * cos(lat2) *
            sin(dLon / 2) * sin(dLon / 2)
    
    val c = 2 * atan2(sqrt(a), sqrt(1 - a))
    
    return (R * c).toFloat()
}
```

#### 实时数据更新

```kotlin
private fun updateSportData(currentPoint: TrackPoint) {
    // 更新总距离
    if (lastPoint != null) {
        val segmentDistance = calculateDistance(lastPoint!!, currentPoint)
        totalDistance += segmentDistance
    }
    
    // 更新运动时长
    val elapsedTime = (System.currentTimeMillis() - startTime) / 1000
    
    // 计算平均速度
    averageSpeed = if (elapsedTime > 0) {
        (totalDistance / elapsedTime) * 3.6f  // 转换为km/h
    } else 0f
    
    // 更新最大速度
    val currentSpeedKmh = currentPoint.speed * 3.6f
    if (currentSpeedKmh > maxSpeed) {
        maxSpeed = currentSpeedKmh
    }
    
    // 估算卡路里消耗（简化公式）
    val distanceKm = totalDistance / 1000f
    calories = (distanceKm * 50).toInt()  // 每公里约50卡路里
    
    // 更新UI
    updateUI()
}
```

### 2. 轨迹缩略图生成

```kotlin
class TrackThumbnailGenerator {
    companion object {
        fun generateThumbnail(
            context: Context,
            trackPoints: List<TrackPoint>,
            width: Int = 400,
            height: Int = 300
        ): String? {
            try {
                // 1. 创建地图视图
                val mapView = TextureMapView(context)
                mapView.onCreate(null)
                
                val aMap = mapView.map
                aMap.apply {
                    mapType = AMap.MAP_TYPE_NORMAL
                    uiSettings.isZoomControlsEnabled = false
                    uiSettings.isCompassEnabled = false
                }
                
                // 2. 添加轨迹线
                val polylineOptions = PolylineOptions()
                trackPoints.forEach { point ->
                    polylineOptions.add(LatLng(point.latitude, point.longitude))
                }
                polylineOptions.color(Color.BLUE)
                polylineOptions.width(10f)
                aMap.addPolyline(polylineOptions)
                
                // 3. 调整地图视野
                val bounds = calculateBounds(trackPoints)
                aMap.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 50))
                
                // 4. 等待地图渲染
                Thread.sleep(1000)
                
                // 5. 截图保存
                aMap.getMapScreenShot(object : AMap.OnMapScreenShotListener {
                    override fun onMapScreenShot(bitmap: Bitmap?) {
                        bitmap?.let { saveThumbnail(it, context) }
                    }
                    
                    override fun onMapScreenShot(bitmap: Bitmap?, status: Int) {
                        onMapScreenShot(bitmap)
                    }
                })
                
                // 6. 释放资源
                mapView.onDestroy()
                
            } catch (e: Exception) {
                e.printStackTrace()
                return null
            }
        }
        
        private fun saveThumbnail(bitmap: Bitmap, context: Context): String {
            val fileName = "track_thumb_${System.currentTimeMillis()}.jpg"
            val file = File(context.filesDir, "thumbnails/$fileName")
            file.parentFile?.mkdirs()
            
            FileOutputStream(file).use { out ->
                bitmap.compress(Bitmap.CompressFormat.JPEG, 80, out)
            }
            
            return file.absolutePath
        }
    }
}
```

### 3. 点赞与评论功能

#### 点赞逻辑

```kotlin
// MomentFragment.kt
private fun handleLike(post: CommunityPostEntity, position: Int) {
    val currentUserId = UserManager.getCurrentUserEmail(requireContext()) ?: return
    
    lifecycleScope.launch {
        try {
            val isLiked = withContext(Dispatchers.IO) {
                sportDatabase.likeDao().isLiked(post.id, currentUserId) > 0
            }
            
            withContext(Dispatchers.IO) {
                if (isLiked) {
                    // 取消点赞
                    sportDatabase.likeDao().deleteLike(post.id, currentUserId)
                } else {
                    // 添加点赞
                    val like = LikeEntity(
                        postId = post.id,
                        userId = currentUserId,
                        timestamp = System.currentTimeMillis()
                    )
                    sportDatabase.likeDao().insertLike(like)
                }
            }
            
            // 重新加载点赞数据
            val newLikeCount = withContext(Dispatchers.IO) {
                sportDatabase.likeDao().getLikeCount(post.id)
            }
            
            val newIsLiked = !isLiked
            
            // 更新UI
            adapter.updateLikeState(position, newIsLiked, newLikeCount)
            
        } catch (e: Exception) {
            Toast.makeText(requireContext(), "操作失败: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
}
```

#### 评论功能

```kotlin
// PostDetailActivity.kt
private fun sendComment() {
    val content = binding.etComment.text.toString().trim()
    
    if (content.isEmpty()) {
        Toast.makeText(this, "请输入评论内容", Toast.LENGTH_SHORT).show()
        return
    }
    
    val currentUserId = UserManager.getCurrentUserEmail(this) ?: return
    val currentUserNickname = UserManager.getCurrentUserNickname(this) ?: "用户"
    val currentUserAvatar = UserManager.getCurrentUserAvatar(this) ?: "ic_twotone_person_24"
    
    val comment = CommentEntity(
        postId = postId,
        userId = currentUserId,
        userNickname = currentUserNickname,
        userAvatar = currentUserAvatar,
        content = content,
        timestamp = System.currentTimeMillis()
    )
    
    lifecycleScope.launch(Dispatchers.IO) {
        try {
            sportDatabase.commentDao().insertComment(comment)
            
            // 获取更新后的评论列表
            val comments = sportDatabase.commentDao().getCommentsForPost(postId)
            
            withContext(Dispatchers.Main) {
                adapter.updateData(comments)
                binding.etComment.setText("")
                
                // 滚动到最新评论
                binding.rvComments.smoothScrollToPosition(comments.size - 1)
                
                Toast.makeText(this@PostDetailActivity, "评论成功", Toast.LENGTH_SHORT).show()
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                Toast.makeText(this@PostDetailActivity, "评论失败: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

### 4. 图片处理与Glide集成

#### Glide配置

```kotlin
// 加载用户头像
Glide.with(context)
    .load(avatarPath)
    .placeholder(R.drawable.ic_twotone_person_24)  // 占位图
    .error(R.drawable.ic_twotone_person_24)        // 错误图
    .centerCrop()
    .into(imageView)

// 加载帖子图片（优化内存）
Glide.with(context)
    .load(imagePath)
    .override(800, 800)  // 限制尺寸，防止OOM
    .centerCrop()
    .into(imageView)
```

#### 图片保存优化

```kotlin
// CreatePostActivity.kt
private fun saveImageToInternalStorage(uri: Uri): String? {
    var savedPath: String? = null
    
    lifecycleScope.launch(Dispatchers.IO) {
        try {
            val inputStream = contentResolver.openInputStream(uri)
            val imagesDir = File(filesDir, "post_images")
            if (!imagesDir.exists()) {
                imagesDir.mkdirs()
            }
            
            val imageFile = File(imagesDir, "post_${System.currentTimeMillis()}.jpg")
            val outputStream = FileOutputStream(imageFile)
            
            inputStream?.use { input ->
                outputStream.use { output ->
                    input.copyTo(output)
                }
            }
            
            savedPath = imageFile.absolutePath
            
            withContext(Dispatchers.Main) {
                Toast.makeText(this@CreatePostActivity, "图片保存成功", Toast.LENGTH_SHORT).show()
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                Toast.makeText(this@CreatePostActivity, "图片保存失败: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }
    
    return savedPath
}
```

---

## UI/UX设计规范

### Material Design 3 主题

#### 颜色系统

```xml
<!-- res/values/colors.xml -->
<resources>
    <!-- Primary 主色 -->
    <color name="md_theme_light_primary">#006C4C</color>
    <color name="md_theme_light_onPrimary">#FFFFFF</color>
    
    <!-- Secondary 辅助色 -->
    <color name="md_theme_light_secondary">#4D6357</color>
    <color name="md_theme_light_onSecondary">#FFFFFF</color>
    
    <!-- Tertiary 第三色 -->
    <color name="md_theme_light_tertiary">#3D6373</color>
    
    <!-- Error 错误色 -->
    <color name="md_theme_light_error">#BA1A1A</color>
    
    <!-- Background 背景色 -->
    <color name="md_theme_light_background">#FBFDF8</color>
    <color name="md_theme_light_onBackground">#191C1A</color>
    
    <!-- Surface 表面色 -->
    <color name="md_theme_light_surface">#FBFDF8</color>
    <color name="md_theme_light_onSurface">#191C1A</color>
</resources>
```

#### 字体系统

```xml
<!-- res/values/themes.xml -->
<style name="TextAppearance.ICyclist.Headline">
    <item name="android:textSize">24sp</item>
    <item name="android:fontFamily">@font/roboto_medium</item>
</style>

<style name="TextAppearance.ICyclist.Body">
    <item name="android:textSize">16sp</item>
    <item name="android:fontFamily">@font/roboto_regular</item>
</style>

<style name="TextAppearance.ICyclist.Caption">
    <item name="android:textSize">12sp</item>
    <item name="android:fontFamily">@font/roboto_regular</item>
</style>
```

### 布局规范

#### 间距系统

```kotlin
// 使用8dp基准网格
spacing_xs = 4dp    // 0.5x
spacing_s = 8dp     // 1x
spacing_m = 16dp    // 2x
spacing_l = 24dp    // 3x
spacing_xl = 32dp   // 4x
spacing_xxl = 48dp  // 6x
```

#### 卡片设计

```xml
<com.google.android.material.card.MaterialCardView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardCornerRadius="12dp"
    app:cardElevation="2dp"
    app:strokeWidth="0dp">
    
    <!-- 卡片内容 -->
    
</com.google.android.material.card.MaterialCardView>
```

### 交互反馈

#### 涟漪效果

```xml
<!-- 按钮点击涟漪 -->
android:background="?attr/selectableItemBackground"

<!-- 圆形涟漪（用于图标按钮） -->
android:background="?attr/selectableItemBackgroundBorderless"
```

#### 状态提示

```kotlin
// Toast提示
Toast.makeText(context, "操作成功", Toast.LENGTH_SHORT).show()

// Snackbar提示（带操作）
Snackbar.make(view, "删除成功", Snackbar.LENGTH_LONG)
    .setAction("撤销") {
        // 撤销操作
    }
    .show()

// Loading对话框
val dialog = ProgressDialog(context).apply {
    setMessage("加载中...")
    setCancelable(false)
}
dialog.show()
```

---

## 性能优化方案

### 1. 内存优化

#### RecyclerView优化

```kotlin
class SportRecordAdapter : RecyclerView.Adapter<SportRecordAdapter.ViewHolder>() {
    
    // ViewHolder复用
    class ViewHolder(val binding: ItemSportRecordBinding) : 
        RecyclerView.ViewHolder(binding.root)
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = ItemSportRecordBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return ViewHolder(binding)
    }
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val record = records[position]
        
        // 使用ViewBinding避免findViewById
        holder.binding.apply {
            tvDistance.text = "%.2f km".format(record.distance / 1000f)
            tvDuration.text = formatDuration(record.duration)
            
            // 使用Glide加载缩略图
            record.thumbnailPath?.let { path ->
                Glide.with(root.context)
                    .load(File(path))
                    .override(200, 150)  // 限制尺寸
                    .into(ivThumbnail)
            }
        }
    }
    
    // 启用局部刷新
    override fun onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList<Any>) {
        if (payloads.isEmpty()) {
            super.onBindViewHolder(holder, position, payloads)
        } else {
            // 处理局部更新
        }
    }
}
```

#### 图片内存优化

```kotlin
// Glide全局配置
@GlideModule
class MyGlideModule : AppGlideModule() {
    override fun applyOptions(context: Context, builder: GlideBuilder) {
        // 设置内存缓存大小
        val memoryCacheSizeBytes = 1024 * 1024 * 20 // 20MB
        builder.setMemoryCache(LruResourceCache(memoryCacheSizeBytes.toLong()))
        
        // 设置磁盘缓存大小
        val diskCacheSizeBytes = 1024 * 1024 * 100 // 100MB
        builder.setDiskCache(InternalCacheDiskCacheFactory(context, diskCacheSizeBytes.toLong()))
    }
}
```

### 2. 启动优化

#### 延迟初始化

```kotlin
class MainContainerActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 立即初始化：核心UI
        setupUI()
        
        // 延迟初始化：非关键组件
        lifecycleScope.launch {
            delay(500)
            initDatabase()
            initAnalytics()
        }
    }
}
```

### 3. 数据库优化

#### 批量操作

```kotlin
// 批量插入，使用事务
@Transaction
@Insert(onConflict = OnConflictStrategy.REPLACE)
suspend fun insertPosts(posts: List<CommunityPostEntity>)
```

#### 分页加载

```kotlin
@Query("SELECT * FROM community_posts ORDER BY timestamp DESC LIMIT :limit OFFSET :offset")
suspend fun getPostsPaged(limit: Int, offset: Int): List<CommunityPostEntity>
```

---

## 安全机制

### 1. 数据加密

#### EncryptedSharedPreferences

```kotlin
object UserManager {
    private fun getEncryptedPreferences(context: Context): SharedPreferences {
        val masterKey = MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
        
        return EncryptedSharedPreferences.create(
            context,
            "user_prefs",
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }
}
```

### 2. 权限管理

```kotlin
// 运行时权限请求
private fun requestLocationPermission() {
    if (ActivityCompat.checkSelfPermission(
            requireContext(),
            Manifest.permission.ACCESS_FINE_LOCATION
        ) != PackageManager.PERMISSION_GRANTED
    ) {
        requestPermissions(
            arrayOf(
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ),
            LOCATION_PERMISSION_REQUEST_CODE
        )
    } else {
        startLocationTracking()
    }
}
```

### 3. 网络安全

```xml
<!-- res/xml/network_security_config.xml -->
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">10.0.2.2</domain>
    </domain-config>
</network-security-config>
```

---

## API接口文档

### 基础URL

```
http://localhost:8080/api/
```

### 用户接口

#### 注册
```http
POST /users/register
Content-Type: application/json

Request:
{
  "email": "user@example.com",
  "nickname": "骑行者",
  "password": "password123"
}

Response:
{
  "success": true,
  "message": "注册成功",
  "data": {
    "userId": 1,
    "email": "user@example.com",
    "nickname": "骑行者"
  }
}
```

#### 登录
```http
POST /users/login
Content-Type: application/json

Request:
{
  "email": "user@example.com",
  "password": "password123"
}

Response:
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "data": {
    "userId": 1,
    "email": "user@example.com",
    "nickname": "骑行者",
    "avatar": "http://..."
  }
}
```

### 运动记录接口

#### 保存运动记录
```http
POST /sport/records
Authorization: Bearer {token}
Content-Type: application/json

Request:
{
  "startTime": 1634567890000,
  "endTime": 1634571490000,
  "duration": 3600,
  "distance": 15000,
  "averageSpeed": 15.5,
  "maxSpeed": 25.8,
  "calories": 750,
  "trackPoints": [...]
}

Response:
{
  "success": true,
  "data": {
    "recordId": 123
  }
}
```

---

## 测试策略

### 单元测试

```kotlin
@RunWith(AndroidJUnit4::class)
class SportDatabaseTest {
    private lateinit var database: SportDatabase
    private lateinit var sportRecordDao: SportRecordDao
    
    @Before
    fun setup() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        database = Room.inMemoryDatabaseBuilder(context, SportDatabase::class.java)
            .build()
        sportRecordDao = database.sportRecordDao()
    }
    
    @Test
    fun insertAndGetSportRecord() = runBlocking {
        val record = SportRecordEntity(
            startTime = System.currentTimeMillis(),
            endTime = System.currentTimeMillis() + 3600000,
            duration = 3600,
            distance = 15000f,
            averageSpeed = 15.5f,
            maxSpeed = 25.8f,
            calories = 750,
            trackPoints = "[]"
        )
        
        sportRecordDao.insertRecord(record)
        val records = sportRecordDao.getAllRecords()
        
        assertEquals(1, records.size)
        assertEquals(15000f, records[0].distance)
    }
    
    @After
    fun tearDown() {
        database.close()
    }
}
```

### UI测试

```kotlin
@RunWith(AndroidJUnit4::class)
@LargeTest
class LoginActivityTest {
    @get:Rule
    val activityRule = ActivityScenarioRule(LoginActivity::class.java)
    
    @Test
    fun testLogin() {
        // 输入邮箱
        onView(withId(R.id.etEmail))
            .perform(typeText("test@example.com"), closeSoftKeyboard())
        
        // 输入密码
        onView(withId(R.id.etPassword))
            .perform(typeText("password123"), closeSoftKeyboard())
        
        // 点击登录按钮
        onView(withId(R.id.btnLogin))
            .perform(click())
        
        // 验证跳转到主页
        intended(hasComponent(MainContainerActivity::class.java.name))
    }
}
```

---

## 附录

### 常用命令

```bash
# 编译项目
./gradlew build

# 安装Debug版本
./gradlew installDebug

# 查看日志
adb logcat | grep "iCyclist"

# 清理项目
./gradlew clean

# 生成APK
./gradlew assembleRelease
```

### 故障排查

1. **GPS定位失败**
   - 检查权限是否授予
   - 确认设备GPS已开启
   - 在室外空旷环境测试

2. **数据库迁移失败**
   - 卸载应用重新安装
   - 检查迁移策略代码

3. **图片加载失败**
   - 检查文件路径是否存在
   - 验证存储权限

---

**文档版本**: 1.0  
**最后更新**: 2025-01-17  
**维护者**: iCyclist开发团队

